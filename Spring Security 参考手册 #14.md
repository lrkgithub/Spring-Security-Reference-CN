### 14 附录



#### 14.1 安全数据库架构

框架使用了各种数据库模式，这个附录为它们全部提供了一个参考。你只需要提供一个数据库表，为你需要的功能领域。

DDL 语句是为了 HSQLDB 数据库提供的。你可以使用这些作为指南，来为你使用的数据库定义架构。



##### 14.1.1 User 架构

`UserDetailsService` （`JdbcDaoImpl`） 的 JDBC 标准实现需要表载入密码，账户状态（使能或未使能），以及用户的一个权限列表。你会需要适配这个架构来匹配你是用的数据库方言。

    create table users(
        username varchar_ignorecase(50) not null primary key,
        password varchar_ignorecase(50) not null,
        enabled boolean not null
    );
    
    create table authorities (
        username varchar_ignorecase(50) not null,
        authority varchar_ignorecase(50) not null,
        constraint fk_authorities_users foreign key(username) references users(username)
    );
    create unique index ix_auth_username on authorities (username,authority);



**对 Oracle 数据库**

```SQL
CREATE TABLE USERS (
    USERNAME NVARCHAR2(128) PRIMARY KEY,
    PASSWORD NVARCHAR2(128) NOT NULL,
    ENABLED CHAR(1) CHECK (ENABLED IN ('Y','N') ) NOT NULL
);
 
CREATE TABLE AUTHORITIES (
	USERNAME NVARCHAR2(128) NOT NULL,
    AUTHORITY NVARCHAR2(128) NOT NULL
);
    ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_UNIQUE UNIQUE (USERNAME, AUTHORITY);
    ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_FK1 FOREIGN KEY (USERNAME) REFERENCES USERS (USERNAME) ENABLE;
```


   



**组权限**

Spring Security 2.0 引入 JdbcDaoImpl 的群组权限的支持。如果组被使能，那么表结构如下。你会需要适配这个架构来匹配你是用的数据库方言。

```SQL
create table groups (
    id bigint generated by default as identity(start with 0) primary key,
    group_name varchar_ignorecase(50) not null
);

create table group_authorities (
    group_id bigint not null,
    authority varchar(50) not null,
    constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

create table group_members (
    id bigint generated by default as identity(start with 0) primary key,
    username varchar(50) not null,
    group_id bigint not null,
    constraint fk_group_members_group foreign key(group_id) references groups(id)
);
```

记住这些表是在你使用提供的 JDBC `UserDetailsService` 实现时才被需要。如果你写了你自己的，或者选择去实现没有 `UserDetailsService` 的 `AuthenticationProvider`，那么你有完全的自主来确定你怎么存储数据，只要接口规范是满足的。



##### 14.1.2 持久化登录 （Remember-me） 架构

这个表被用来存储更安全的 persistent token remember-me 实现的相关数据。如果正在使用 JdbcTokenRepositoryImpl，要不就直接使用，要不就通过命名空间，然后你需要这个数据库表。记得来适配这个架构来匹配你正在使用的数据库方言。

```SQL
create table persistent_logins (
    username varchar(64) not null,
    series varchar(64) primary key,
    token varchar(64) not null,
    last_used timestamp not null
);
```



##### 14.1.3 ACL 框架

这是 Spring Security ACL 实现使用的四个库。

1. `acl_sid` 存储了可以被 ACL 系统识别的安全标识符。这可以是唯一的 principal 或 authorities 可以应用到多个 principal 上。
2. `acl_class` 定义了 ACL 可以应用到的领域对象。`class` 列存储了对象的 Java 类名。
3. `acl_object_identity` 存储了特定领域对象的对象标识定义。
4. `acl_entry` 存储了 ACL 许可，这个会应用到特定的对象标志和安全标志。

可以认为，数据库会每一个标志自动生成主键。`JdbcMutableAclService` 必须能够来获取这些，挡在 `acl_sid` 或 `acl_calss` 表创建一个新的行时。这有两个属性，用于定义搜索这些值 `classIdentityQuery` 和 `sidIdentityQuery` 的 SQL 语句。两者的默认都是 `call identity()`。

ACL 目标 JAR 包含了在 HyperSQL（HSQLDB），PostgreSQL，MySQL/MariaDB，Microsoft SQL，和 Oracle Database 的 ACL 架构。这些结构在下以节展示。



**HyperSQL**

默认结构配合嵌入式 HSQLDB 一起工作，框架在单元测试中使用它。

```SQL
create table acl_sid(
    id bigint generated by default as identity(start with 100) not null primary key,
    principal boolean not null,
    sid varchar_ignorecase(100) not null,
    constraint unique_uk_1 unique(sid,principal)
);

create table acl_class(
    id bigint generated by default as identity(start with 100) not null primary key,
    class varchar_ignorecase(100) not null,
    constraint unique_uk_2 unique(class)
);

create table acl_object_identity(
    id bigint generated by default as identity(start with 100) not null primary key,
    object_id_class bigint not null,
    object_id_identity varchar_ignorecase(36) not null,
    parent_object bigint,
    owner_sid bigint,
    entries_inheriting boolean not null,
    constraint unique_uk_3 unique(object_id_class,object_id_identity),
    constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),
    constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),
    constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id)
);

create table acl_entry(
    id bigint generated by default as identity(start with 100) not null primary key,
    acl_object_identity bigint not null,
    ace_order int not null,
    sid bigint not null,
    mask integer not null,
    granting boolean not null,
    audit_success boolean not null,
    audit_failure boolean not null,
    constraint unique_uk_4 unique(acl_object_identity,ace_order),
    constraint foreign_fk_4 foreign key(acl_object_identity) references acl_object_identity(id),
    constraint foreign_fk_5 foreign key(sid) references acl_sid(id)
);
```



**PostgreSQL**

```SQL
create table acl_sid(
    id bigserial not null primary key,
    principal boolean not null,
    sid varchar(100) not null,
    constraint unique_uk_1 unique(sid,principal)
);

create table acl_class(
    id bigserial not null primary key,
    class varchar(100) not null,
    constraint unique_uk_2 unique(class)
);

create table acl_object_identity(
    id bigserial primary key,
    object_id_class bigint not null,
    object_id_identity varchar(36) not null,
    parent_object bigint,
    owner_sid bigint,
    entries_inheriting boolean not null,
    constraint unique_uk_3 unique(object_id_class,object_id_identity),
    constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),
    constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),
    constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id)
);

create table acl_entry(
    id bigserial primary key,
    acl_object_identity bigint not null,
    ace_order int not null,
    sid bigint not null,
    mask integer not null,
    granting boolean not null,
    audit_success boolean not null,
    audit_failure boolean not null,
    constraint unique_uk_4 unique(acl_object_identity,ace_order),
    constraint foreign_fk_4 foreign key(acl_object_identity) references acl_object_identity(id),
    constraint foreign_fk_5 foreign key(sid) references acl_sid(id)
);
```

你将需要设置 `JdbcMutableAclService` 中的 `classIdentityQuery` 和 `sidIdentityQuery` 属性来获得这些值，分别是：

* `select currval(pg_get_serial_sequence('acl_class', 'id'))`
* `select currval(pg_ge_serial_sequence('acl_sid', 'id'))`



**MySQL 和 MariaDB**

```SQL
CREATE TABLE acl_sid (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    principal BOOLEAN NOT NULL,
    sid VARCHAR(100) NOT NULL,
    UNIQUE KEY unique_acl_sid (sid, principal)
) ENGINE=InnoDB;

CREATE TABLE acl_class (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    class VARCHAR(100) NOT NULL,
    UNIQUE KEY uk_acl_class (class)
) ENGINE=InnoDB;

CREATE TABLE acl_object_identity (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    object_id_class BIGINT UNSIGNED NOT NULL,
    object_id_identity VARCHAR(36) NOT NULL,
    parent_object BIGINT UNSIGNED,
    owner_sid BIGINT UNSIGNED,
    entries_inheriting BOOLEAN NOT NULL,
    UNIQUE KEY uk_acl_object_identity (object_id_class, object_id_identity),
    CONSTRAINT fk_acl_object_identity_parent FOREIGN KEY (parent_object) REFERENCES acl_object_identity (id),
    CONSTRAINT fk_acl_object_identity_class FOREIGN KEY (object_id_class) REFERENCES acl_class (id),
    CONSTRAINT fk_acl_object_identity_owner FOREIGN KEY (owner_sid) REFERENCES acl_sid (id)
) ENGINE=InnoDB;

CREATE TABLE acl_entry (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    acl_object_identity BIGINT UNSIGNED NOT NULL,
    ace_order INTEGER NOT NULL,
    sid BIGINT UNSIGNED NOT NULL,
    mask INTEGER UNSIGNED NOT NULL,
    granting BOOLEAN NOT NULL,
    audit_success BOOLEAN NOT NULL,
    audit_failure BOOLEAN NOT NULL,
    UNIQUE KEY unique_acl_entry (acl_object_identity, ace_order),
    CONSTRAINT fk_acl_entry_object FOREIGN KEY (acl_object_identity) REFERENCES acl_object_identity (id),
    CONSTRAINT fk_acl_entry_acl FOREIGN KEY (sid) REFERENCES acl_sid (id)
) ENGINE=InnoDB;
```



**Microsoft SQL Server**

```SQL
CREATE TABLE acl_sid (
    id BIGINT NOT NULL IDENTITY PRIMARY KEY,
    principal BIT NOT NULL,
    sid VARCHAR(100) NOT NULL,
    CONSTRAINT unique_acl_sid UNIQUE (sid, principal)
);

CREATE TABLE acl_class (
    id BIGINT NOT NULL IDENTITY PRIMARY KEY,
    class VARCHAR(100) NOT NULL,
    CONSTRAINT uk_acl_class UNIQUE (class)
);

CREATE TABLE acl_object_identity (
    id BIGINT NOT NULL IDENTITY PRIMARY KEY,
    object_id_class BIGINT NOT NULL,
    object_id_identity VARCHAR(36) NOT NULL,
    parent_object BIGINT,
    owner_sid BIGINT,
    entries_inheriting BIT NOT NULL,
    CONSTRAINT uk_acl_object_identity UNIQUE (object_id_class, object_id_identity),
    CONSTRAINT fk_acl_object_identity_parent FOREIGN KEY (parent_object) REFERENCES acl_object_identity (id),
    CONSTRAINT fk_acl_object_identity_class FOREIGN KEY (object_id_class) REFERENCES acl_class (id),
    CONSTRAINT fk_acl_object_identity_owner FOREIGN KEY (owner_sid) REFERENCES acl_sid (id)
);

CREATE TABLE acl_entry (
    id BIGINT NOT NULL IDENTITY PRIMARY KEY,
    acl_object_identity BIGINT NOT NULL,
    ace_order INTEGER NOT NULL,
    sid BIGINT NOT NULL,
    mask INTEGER NOT NULL,
    granting BIT NOT NULL,
    audit_success BIT NOT NULL,
    audit_failure BIT NOT NULL,
    CONSTRAINT unique_acl_entry UNIQUE (acl_object_identity, ace_order),
    CONSTRAINT fk_acl_entry_object FOREIGN KEY (acl_object_identity) REFERENCES acl_object_identity (id),
    CONSTRAINT fk_acl_entry_acl FOREIGN KEY (sid) REFERENCES acl_sid (id)
);
```



**Oracle Database**

```SQL
CREATE TABLE ACL_SID (
    ID NUMBER(18) PRIMARY KEY,
    PRINCIPAL NUMBER(1) NOT NULL CHECK (PRINCIPAL IN (0, 1 )),
    SID NVARCHAR2(128) NOT NULL,
    CONSTRAINT ACL_SID_UNIQUE UNIQUE (SID, PRINCIPAL)
);
CREATE SEQUENCE ACL_SID_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER ACL_SID_SQ_TR BEFORE INSERT ON ACL_SID FOR EACH ROW
BEGIN
    SELECT ACL_SID_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;


CREATE TABLE ACL_CLASS (
    ID NUMBER(18) PRIMARY KEY,
    CLASS NVARCHAR2(128) NOT NULL,
    CONSTRAINT ACL_CLASS_UNIQUE UNIQUE (CLASS)
);
CREATE SEQUENCE ACL_CLASS_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER ACL_CLASS_ID_TR BEFORE INSERT ON ACL_CLASS FOR EACH ROW
BEGIN
    SELECT ACL_CLASS_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;


CREATE TABLE ACL_OBJECT_IDENTITY(
    ID NUMBER(18) PRIMARY KEY,
    OBJECT_ID_CLASS NUMBER(18) NOT NULL,
    OBJECT_ID_IDENTITY NVARCHAR2(64) NOT NULL,
    PARENT_OBJECT NUMBER(18),
    OWNER_SID NUMBER(18),
    ENTRIES_INHERITING NUMBER(1) NOT NULL CHECK (ENTRIES_INHERITING IN (0, 1)),
    CONSTRAINT ACL_OBJECT_IDENTITY_UNIQUE UNIQUE (OBJECT_ID_CLASS, OBJECT_ID_IDENTITY),
    CONSTRAINT ACL_OBJECT_IDENTITY_PARENT_FK FOREIGN KEY (PARENT_OBJECT) REFERENCES ACL_OBJECT_IDENTITY(ID),
    CONSTRAINT ACL_OBJECT_IDENTITY_CLASS_FK FOREIGN KEY (OBJECT_ID_CLASS) REFERENCES ACL_CLASS(ID),
    CONSTRAINT ACL_OBJECT_IDENTITY_OWNER_FK FOREIGN KEY (OWNER_SID) REFERENCES ACL_SID(ID)
);
CREATE SEQUENCE ACL_OBJECT_IDENTITY_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER ACL_OBJECT_IDENTITY_ID_TR BEFORE INSERT ON ACL_OBJECT_IDENTITY FOR EACH ROW
BEGIN
    SELECT ACL_OBJECT_IDENTITY_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;


CREATE TABLE ACL_ENTRY (
    ID NUMBER(18) NOT NULL PRIMARY KEY,
    ACL_OBJECT_IDENTITY NUMBER(18) NOT NULL,
    ACE_ORDER INTEGER NOT NULL,
    SID NUMBER(18) NOT NULL,
    MASK INTEGER NOT NULL,
    GRANTING NUMBER(1) NOT NULL CHECK (GRANTING IN (0, 1)),
    AUDIT_SUCCESS NUMBER(1) NOT NULL CHECK (AUDIT_SUCCESS IN (0, 1)),
    AUDIT_FAILURE NUMBER(1) NOT NULL CHECK (AUDIT_FAILURE IN (0, 1)),
    CONSTRAINT ACL_ENTRY_UNIQUE UNIQUE (ACL_OBJECT_IDENTITY, ACE_ORDER),
    CONSTRAINT ACL_ENTRY_OBJECT_FK FOREIGN KEY (ACL_OBJECT_IDENTITY) REFERENCES ACL_OBJECT_IDENTITY (ID),
    CONSTRAINT ACL_ENTRY_ACL_FK FOREIGN KEY (SID) REFERENCES ACL_SID(ID)
);
CREATE SEQUENCE ACL_ENTRY_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER ACL_ENTRY_ID_TRIGGER BEFORE INSERT ON ACL_ENTRY FOR EACH ROW
BEGIN
    SELECT ACL_ENTRY_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;
```



#### 14.2 安全命名空间



----- 命名空间部分省去  ------



#### 14.3 Spring Security 依赖

这部分附录提供了一份 Spring Security 引用模块的引用，以及运行时其余功能的额外依赖。这些依赖只有在，构建或测试 Spring Security 自己时才需要。我们也不包括外部依赖所需的传递依赖。

所需要的 Spring 版本列在了项目站点上，因此下面的 Spring 依赖项省略了特定的版本。注意这一点，一些依赖在下面被列为 “可选的”，但在运用到 Spring 应用中的非安全功能时仍旧需要。而且，被列为 “可选的” 在项目的 Maven POM 文件可能不是真的这么标记的，如果他们在大多数项目中被使用了。他们只有在除非你使用了特殊功能才需要的场景下，才是 “可选的”。

当一个模块依赖另一个 Spring Security 模块时，哪些非可选的依赖模块也被认为是需要的，而且没有被分别列出。



##### 14.3.1 spring-security-core

在任何使用 Spring Security 的项目中，核心模块必须被包含。

**Table 14.1. Core Dependencies**

| Dependency        | Version | Description                                                  |
| ----------------- | ------- | ------------------------------------------------------------ |
| ehcache           | 1.6.2   | Required if the Ehcache-based user cache implementation is used (optional). |
| spring-aop        |         | Method security is based on Spring AOP                       |
| spring-beans      |         | Required for Spring configuration                            |
| spring-expression |         | Required for expression-based method security (optional)     |
| spring-jdbc       |         | Required if using a database to store user data (optional).  |
| spring-tx         |         | Required if using a database to store user data (optional).  |
| aspectjrt         | 1.6.10  | Required if using AspectJ support (optional).                |
| jsr250-api        | 1.0     | Required if you are using JSR-250 method-security annotations (optional). |



##### 14.3.2 spring-security-remoting

这是只有在使用 Servlet API 的 web 项目中才需要的模块。

**Table 14.2. Remoting Dependencies**

| Dependency           | Version | Description                                           |
| -------------------- | ------- | ----------------------------------------------------- |
| spring-security-core |         |                                                       |
| spring-web           |         | Required for clients which use HTTP remoting support. |



##### 14.3.3 spring-security-web

这是只有在使用 Servlet API 的 web 项目中才需要的模块。

**Table 14.3. Web Dependencies**

| Dependency           | Version | Description                                                  |
| -------------------- | ------- | ------------------------------------------------------------ |
| spring-security-core |         |                                                              |
| spring-web           |         | Spring web support classes are used extensively.             |
| spring-jdbc          |         | Required for JDBC-based persistent remember-me token repository (optional). |
| spring-tx            |         | Required by remember-me persistent token repository implementations (optional). |



##### 14.3.4 spring-security-ladp

只有你在使用 LDAP 认证时，才被需要的模块

**Table 14.4. LDAP Dependencies**

| Dependency                                                   | Version | Description                                                  |
| ------------------------------------------------------------ | ------- | ------------------------------------------------------------ |
| spring-security-core                                         |         |                                                              |
| spring-ldap-core                                             | 1.3.0   | LDAP support is based on Spring LDAP.                        |
| spring-tx                                                    |         | Data exception classes are required.                         |
| apache-ds [[1\]](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#ftn.d5e9684) | 1.5.5   | Required if you are using an embedded LDAP server (optional). |
| shared-ldap                                                  | 0.9.15  | Required if you are using an embedded LDAP server (optional). |
| ldapsdk                                                      | 4.1     | Mozilla LdapSDK. Used for decoding LDAP password policy controls if you are using password-policy functionality with OpenLDAP, for example. |
| [[1\] ](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#d5e9684)The modules `apacheds-core`, `apacheds-core-entry`, `apacheds-protocol-shared`, `apacheds-protocol-ldap` and `apacheds-server-jndi` are required. |         |                                                              |



##### 14.3.5 spring-security-config

这是只有在你是用 Spring Security 命名空间时才需要的模块。

**Table 14.5. Config Dependencies**

| Dependency             | Version | Description                                                  |
| ---------------------- | ------- | ------------------------------------------------------------ |
| spring-security-core   |         |                                                              |
| spring-security-web    |         | Required if you are using any web-related namespace configuration (optional). |
| spring-security-ldap   |         | Required if you are using the LDAP namespace options (optional). |
| spring-security-openid |         | Required if you are using OpenID authentication (optional).  |
| aspectjweaver          | 1.6.10  | Required if using the protect-pointcut namespace syntax (optional). |



##### 14.3.6 spring-security-acl

ACL 模块。

**Table 14.6. ACL Dependencies**

| Dependency           | Version | Description                                                  |
| -------------------- | ------- | ------------------------------------------------------------ |
| spring-security-core |         |                                                              |
| ehcache              | 1.6.2   | Required if the Ehcache-based ACL cache implementation is used (optional if you are using your own implementation). |
| spring-jdbc          |         | Required if you are using the default JDBC-based AclService (optional if you implement your own). |
| spring-tx            |         | Required if you are using the default JDBC-based AclService (optional if you implement your own). |



##### 14.3.7 spring-security-cas

CAS 模块提供了与 JA-SIG CAS 的集成。

**Table 14.7. CAS Dependencies**

| Dependency           | Version | Description                                                  |
| -------------------- | ------- | ------------------------------------------------------------ |
| spring-security-core |         |                                                              |
| spring-security-web  |         |                                                              |
| cas-client-core      | 3.1.12  | The JA-SIG CAS Client. This is the basis of the Spring Security integration. |
| ehcache              | 1.6.2   | Required if you are using the Ehcache-based ticket cache (optional). |



##### 14.3.8 spring-security-openid

OpenID 模块。

**Table 14.8. OpenID Dependencies**

| Dependency           | Version | Description                                            |
| -------------------- | ------- | ------------------------------------------------------ |
| spring-security-core |         |                                                        |
| spring-security-web  |         |                                                        |
| openid4java-nodeps   | 0.9.6   | Spring Security’s OpenID integration uses OpenID4Java. |
| httpclient           | 4.1.1   | openid4java-nodeps depends on HttpClient 4.            |
| guice                | 2.0     | openid4java-nodeps depends on Guice 2.                 |



##### 14.3.9 spring-security-taglibs

提供了 Spring Security 的 `JSP` 标签实现。

**Table 14.9. Taglib Dependencies**

| Dependency           | Version | Description                                                  |
| -------------------- | ------- | ------------------------------------------------------------ |
| spring-security-core |         |                                                              |
| spring-security-web  |         |                                                              |
| spring-security-acl  |         | Required if you are using the `accesscontrollist` tag or `hasPermission()` expressions with ACLs (optional). |
| spring-expression    |         | Required if you are using SPEL expressions in your tag access constraints. |



#### 14.4 Proxy 服务器配置

当使用一个代理服务器时，确保你已经正确配置了你的应用是很重要的。比如说，很多应用可能有一个负载均衡器，它将对 `https://example.com` 的请求，导向到位于 `https://192.168.1.0:8080`。没有合适的配置，应用服务器不会知道负载均衡器的存在，并认为请求是直接被客户端请求的一样。

为了做好这一点，你可以使用 `RFC 7239` 来指定一个负载均衡器正在被使用。为了使应用知道它，你也需要配置你的应用服务器感知 `X-Forwarded` 头部。比如说，Tomcat 使用 `RemoteIpValue`，Jetty 使用 `ForwardedRequestCustomizer`。另外，Spring 4.3+ 用户可以利用 `ForwardedHeaderFilter`。



#### 14.5 Spring Security FAQ

* 14.5.1，“一般问题”
* 14.5.2，”常见问题“
* 14.5.3，“Spring Security 架构问题”
* 14.5.4，“常见 ‘怎么做’ 问题”



##### 14.5.1 一般问题

1. Spring Security 会处理我应用的所有安全性需求吗？
2. 为什么不只使用 `web.xml`安全？
3. Java 和 Spring Framework 版本有要求吗？
4. 我是 Spring Security 新手，我需要构建一个应用支持 HTTPS 上的 CAS 单点登录，同时允许某些 URL 进行本地 Basic 认证，针对多个后端用户信息源（LDAP 和 JDBC）进行身份验证。我复制了一些配置文件，但我发现这并不起作用。



**Spring Security 会处理我应用的所有安全性需求吗？**

 Spring Security 提供给你一个灵活的框架，来处理你的认证和授权需求，但是要构建一个安全应用，这里还是有许多需要考虑的问题是在他的范围之外的。Web 应用对各种你熟悉的攻击时无力的，最好在正式开发之前，就设计好并在编码时考虑到。查看这个网址，`http://www.owasp.org/[OWASP web site] `，来获取 web 应用开发者所要面对的主要问题的相关信息，以及你可以使用的对策。



**为什么不只使用 `web.xml`安全？**

让我们假设我们基于 Spring 开发一个商业应用。这里有四个方面的安全问题你需要特别关心：认证，web 请求安全，业务层安全（比如，你的方法实现了业务逻辑），以及领域对象实例安全（比如，不同的领域对象拥有不同的许可）。带着这四个问题在心中：

1. 认证：基于 Servlet 的应用提供了一种认证的方式。然而，你需要配置容器来执行认证，这典型地需要修改容器特有的 `realm` 设置。这需要一个不可移植的配置，而如果你需要写一个真正的 Java 类来实现容器的认证接口，那么它就变得更加难以移植。有了 Spring Security 你就可以达到完全的可移植 - 直到 WAR 级别。还有，Spring Security 提供了经过生产验证的认证 provider 和机制的一个选择，意味着你可以在部署时切换你的认证方式。这对软件提供者编写需要在未知环境工作的产品时，特别有用。
2. Web 请求安全：Servlet 规范提供了一种方式来安全你的请求 URI。然而，这些 URI 只能在 Servlet 规范自己的受限的 URI 路劲模式下被表示。Spring Security 提供了一个全面的多的的方式。例如，你可以使用 Ant 路径或者正则表达式，你可以考虑 URI 的部分而不仅仅是请求的页面（比如，你可以考虑 HTTP GET 参数），你可以实现你自己的运行时配置数据源。这意味着你的 web 请求安全可以被异步改变，在你的 webapp 实际执行时候。

3. 服务层和领域对象安全：在 Servlet 规范中对服务层以及领域对象实例安全性在多层次应用中的表达是缺乏支持。通常，开发者要不就忽略这些需求，要不就在 MVC controller 的代码中实现安全逻辑（或者，更糟糕，在视图内部）。这种方式有一些严重的缺陷：

   a. 关注点分离：认证是一个横切关注点，而且应该被这样实现。MVC controller 或者实视图实现认证代码，会使它更难测试 controller 和认证逻辑，更难 debug，经常会导致代码重复。

   b. 对富客户端和 web service 的支持：如果一个额外的客户类型必须被最终支持，任何嵌入在 web 层中的认证代码都是不可重用的。应该考虑 Spring remote exporters 只导出服务层 beans（而不是 MVC controller）。因此需要在服务层定为这些认证逻辑，来支持多种客户的类型。

   c. 分层问题：一个 MVC Controller 或者视图，是明显的一个错误架构来实现关于服务层方法和领域对象实例的安全决策。同时，Principal 需要被传递给服务层来使能它做出认证决策，这回导致引入一个额外的入参到每个服务层方法。一个更优雅的方式，是使用一个 ThreadLocal 来持有 Principal，尽管这会增加开发时间，以至于使用一个专用的安全框架会是更经济的（或者基于成本效益）。

   d. 认证代码质量：经常说，web 框架，“让做正确的事更容易，让做错误的事情更难”。安全框架也是一样的，因为他们被设计为基于一个抽象的方式，以用于更大范围的目的。编写你自己的认证代码通常缺少一个框架可以提供的 “设计检查”，一个内部认证代码也缺乏广泛部署，同行评审，新版本持续改进，这些优势。

   对于一个简单的应用，Servlet 规范安全可能就足够了。尽管，当考虑到 web 容器的上下文可移植性，配置需求，受限的 web 请求安全灵活，一个不存在的服务层和领域对象实例安全，它就很明了为什么开发者们经常寻找额外的解决方法。



**Java 和 Spring Framework 版本有要求吗？**

Spring Security 3.0 和 3.1 需要至少 JDK 1.5，也需要 Spring 3.0.3 至少。理想情况下，你应该使用最新版本来避免一些问题。

Spring Security 2.x 需要最少 JDK 版本 1.4，并基于 Spring 2.0.x。它应该与使用 Spring 2.5.x 的应用兼容。



**我是 Spring Security 新手，我需要构建一个应用支持 HTTPS 上的 CAS 单点登录，同时允许某些 URL 进行本地 Basic 认证，针对多个后端用户信息源（LDAP 和 JDBC）进行身份验证。我复制了一些配置文件，但我发现这并不起作用。**

什么地方可能错了？

或者，替代另一种复杂的场景......

讲真，你需要对你想要使用的技术有一些理解，在你可以成功的使用他们来搭建你的应用。安全是复杂的。设置一个简单的配置，使用表单登录，使用 Spring Security 的命名空间写一些硬编码的用户，是相当简单的。进而，使用一个 JDBC 数据库后端也是简单的。但是如果你试着跳过这些，直接来到复杂的部署场景，像问题中这个，你几乎一定会很沮丧。这里有一个陡峭的学习曲线，设置 CAS 系统，配置 LDAP 服务器，正确安装 SSL 证书等等。

透视一个 Spring Security，第一件你需要做的事是你应该学习 web 网站上的 “Getting Started” 部分。这会带你通过一系列的设置，运行，理解系统是怎么运行的。如果你正在使用另一些你并不熟悉的技术，你应该先做一些研究，并在将他们融入复杂的系统之前，确保你可以独立地使用它们。



##### 14.5.2 常见问题

1. 认证

   a. 当我试着登录，我得到一个错误信息，“Bad Credentials”。哪里出错了？

   b. 当我尝试登录时，我的应用进入一个 “死循环”，这是怎么回事？

   c. 我得到一个报错信息，“Access is denied(user is anonymous)”，哪里出错了？

   d. 在我登出应用之后，我为什么还可以看到安全页面？

   e. 我得到一个报错信息，"An Authentication object was not found in the SecurityContext"，哪里出错了？

      f. 我的 LDAP 认证不能工作了

   2. 会话管理

      a. 使用 Spring Security 的会话管理来防止用户不止一次的登录

      b. 当我通过 Spring Security 认证后，会话 id 发生了变化。

      c. 我使用 Tomcat，或其他 Servlet 容器，并为我的登录页面使能了 HTTPS，以后怎么切换回 HTTP。

      d. 我正尝试使用当前的会话管理支持，但是我不能登录回去，即使我确定我已经登出，而且没有超出允许的会话。

      e. Spring Security 在什么地方新建了会话，就算是我配置它去不要新建，通过设置 create-session 属性为 never。

   3. 杂项

      a. 当执行一个 POST 时，我得到一个 403 Forbidden 回复。

      b. 我使用 RequestDispatcher 转发一个请求到另一个 URL 地址，但我的安全限制并没有生效。

      c. 我在应用上下文中增加 Spring Security 到 `<global-method-security>` 属性，但是，如果我增加安全注解到 Spring MVC controller beans（Struts beans，等等） 时，它们好像没有生效。

      d. 我有一个用户，他一定已经被授权，但是当我在一些请求中试着访问 SpringSecurityContextHolder 时，Authentication 是 null。

      e. 认证 JSP 标签没有按我的方法安全注解生效，在使用 URL 属性时

   

   **当我试着登录，我得到一个错误信息，“Bad Credentials”。哪里出错了？**

   这意味着认证失败了。它并没有说为什么，这是一个好的实践，因为这可以避免由于泄露细节而使攻击者猜到账户的名字或密码。

   这同样意味着，如果你在论坛上提出了这个问题，你可能不会得到回复，除非你提出了另外的信息。与任何问题一样，你应该检查 debug 日志的输出，之一任何异常堆栈和相关的信息。逐步调试调试器中的代码，以查看身份验证失败的原因和原因。在应用之外。写一个测试用例来验证你的认证配置。通常，这个失败是因为存储在数据库中的密码和用户输入的密码不一致导致的。如果正在使用哈希密码，确保你存在数据库中的值正式被你的应用配置的 `PasswordEncoder` 产生的值。

   **我尝试登录时，我的应用进入一个 “死循环”，这是怎么回事？ **

   一个常见的用户问题，无止进地重定向到登录页面，这是由于意外地将登陆页面配置为 “安全” 资源。确保你的配置允许匿名用户访问登录页面，要不通过将它排除在安全过滤器链之外，要不就标志它为 “ROLE_ANONYMOUS”。

   如果你的 `AccessDecisionManager` 包括一个 `AuthenticatedVoter`，你可以使用属性 “IS_AUTHENTICATED_ANONYMOUSLY”。如果你使用标准的命名空间配置启动，这是自动可用的。

   从 Spring Security 2.0.1 开始，当你正在基于命名空间的配置，在加载应用上下文时会检查你的登录页面看上去是受保护的，那么一个提示信息会被给出。

   

   **我得到一个报错信息，“Access is denied(user is anonymous)”，哪里出错了？**

   这是一个 debug 级别的信息，这在第一次匿名用户尝试访问受保护的资源时会给出。

   ```LOG
   DEBUG [ExceptionTranslationFilter] - Access is denied (user is anonymous); redirecting to authentication entry point
   org.springframework.security.AccessDeniedException: Access is denied
   at org.springframework.security.vote.AffirmativeBased.decide(AffirmativeBased.java:68)
   at org.springframework.security.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:262)
   ```

   很常见，不需要担心。

   

   **在我登出应用之后，我为什么还可以看到安全页面？**

   最常见的原因是你的浏览器缓存了你的页面，你看到的是一个从浏览器中缓存的拷贝。可以通过检查你的流量拿起是否真的发送了请求来判断（检查你的服务器访问日志，debug 日志或使用一个合适的浏览器 debug 插件，例如 Firefox 的 “Tamper Data”）。这和 Spring Security 没有关系，你应该配置你的应用或者服务器，设置合适的 `Cache-Control` 返回头部。注意，SSL 请求永远不会被缓存。

   

   **我得到一个报错信息，"An Authentication object was not found in the SecurityContext"，哪里出错了？**

   这是另一个 debug 级别的信息，这发生在匿名用户第一次尝试访问受保护的资源时，但是这是在你没有给你的过滤器链配置一个 `AnonymousAuthenticationilter` 时。

   ```LOG
   DEBUG [ExceptionTranslationFilter] - Authentication exception occurred; redirecting to authentication entry point
   org.springframework.security.AuthenticationCredentialsNotFoundException:
                               An Authentication object was not found in the SecurityContext
   at org.springframework.security.intercept.AbstractSecurityInterceptor.credentialsNotFound(AbstractSecurityInterceptor.java:342)
   at org.springframework.security.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:254)
   ```

   很常见，不需要担心。

   

   **我的 LDAP 认证不能工作了会话管理**

   我的配置出什么问题了？

   注意到，LDAP 目录的许可经常不允许你读取用户的密码。因此，通常不能用 [“What is a UserDetailsService and do I need one?”](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#appendix-faq-what-is-userdetailservice)  章节的内容，因为 Spring Security 将存储的密码和用户提交的密码进行比较。最常见的方式，是使用 LDAP “bind”，这是 LDAP 协议支持的一个动作。通过这个方式，Spring Security 可以通过尝试以用户身份验证目录来验证密码。

   LDAP 认证最常见的问题是缺少对目录服务器数装结构和配置的认知。这在不同的公司是不同的，所以你需要自己去解决。在增加一个 Spring Security LDAP 配置到你的应用之前，用标准 Java LDAP 代码写一个简单用例是个好主意（不包括 Spring Security），并确保你能使它正常工作。比如说，认证一个用户，你可以使用以下代码：

   ```Java
   @Test
   public void ldapAuthenticationIsSuccessful() throws Exception {
           Hashtable<String,String> env = new Hashtable<String,String>();
           env.put(Context.SECURITY_AUTHENTICATION, "simple");
           env.put(Context.SECURITY_PRINCIPAL, "cn=joe,ou=users,dc=mycompany,dc=com");
           env.put(Context.PROVIDER_URL, "ldap://mycompany.com:389/dc=mycompany,dc=com");
           env.put(Context.SECURITY_CREDENTIALS, "joespassword");
           env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
   
           InitialLdapContext ctx = new InitialLdapContext(env, null);
   
   }
   ```

   

   **会话管理**

   会话管理是一个常见的论坛问题来源。如果你正在开发一个 Java web 应用，你应该明白 session 在 Servlet 容器与用户浏览器之间是怎么维护的。你也应用理解，安全和非安全 cookie 的区别，使用 HTTP/HTTPS 的意义，以及怎么在两者之间切换。Spring Security 对维护会话，以及提供会话标志这些工作什么也没做。这完全是 Servlet 容器处理的。

   

   **使用 Spring Security 的会话管理来防止用户不止一次的登录**

   当我在登录之后，打开另一个浏览器界面，这不能阻止我再一次登录。为什么我可以不止一次的登录。

   浏览器对每一个浏览器实例，总会维持一个单独的会话。你不能拥有一次性拥有两个分开的会话。所以，如果你在另一个浏览器或页签再次登录，你只是再一次认证了同一个会话。服务器不会知道页签，页面或浏览器实例的事情。它看到的是 HTTP 请求，把这些和一个特定的会话连接在一起，通过它持有的 JSESSIONID cookie 的值。当一个用户在一个会话中认证，Spring Security 的当前会话控制，检查他们拥有的认证过的会话数量。如果已经在同一个会话中认证了，那么再次认证不会产生任何效果。

   

   **当我通过 Spring Security 认证后，会话 id 发生了变化**

   对于默认配置，Spring Security 改变了会话 id，当用户认证之后。如果使用的是 Servlet 3.1 或者更新的容器，会话 ID 就会简单地改变。如果你正在使用老一点的容器，Spring Security 会使已存在会话无效，新建一个会话毛病将会话的数据传给新的会话。用这种方式改变会话标志，可以预防 ”session-fixation“ 攻击。你可以在线上找到更多的信息，以及这份参考手册中。

   

   **我使用 Tomcat，或其他 Servlet 容器，并为我的登录页面使能了 HTTPS，以后怎么切换回 HTTP。**

   这不会生效的。我只在认证之后，在登录页面结束了后端。

   因为会话是在 HTTPS 下创建的，所以会话 cookie 会被标志为 “secure”，随后不能在 HTTP 下使用。浏览器不会发送 cookie 回服务器，任何会话状态会丢失（包括安全上下文信息）。在 HTTP 下启动一个会话，首先应该以 cookie 不会被标志为 “secure” 开始工作。然而，Spring Security 的 Session Fixation Protection 可以干扰这一点，因为它产生了一个新的会话 ID cookie，被发送回用户的浏览器。通常带着安全标志。注意，在 HTTP 和 HTTPS之间切换，总的来说不是一个好主意，正如任何应用使用 HTTP 都可能受到中间人攻击。为了真正的安全，用户应该先用 HTTPS 登录你的站点，并继续使用这个协议知道登出。即使点击 HTTP 页面的 HTTPS 连接也是有安全风险的。如果你需要增强一点说服力，请查看像 `sslstrip` 这样的工具。

   

   **我没有在 HTTP 或 HTTPS 之间切换，单我的会话仍旧丢失了 **

   会话的维持，要不依靠会话 cookie 的交换，要不通过增加一个 `jsessionid` 参数到 URL中（如果你是用 `JSTL` 来发布 URL，这会自动发生），或者你在 URL 上调用 `HttpServletResponse.encodeUrl` （比如，在一个重定向之前）。如果用户将 cookie 关闭，你就不能重写 URL 以包含 `jsessionid`，那么会话就会丢失。注意到，cookie 的使用更倾向于一种安全理由，因为它不会暴露在 URL 中暴露会话信息。

   

   **我正尝试使用当前的会话管理支持，但是我不能登录回去，即使我确定我已经登出，而且没有超出允许的会话。**

   确保你已经在你的 `web.xml` 中增加了监听器。这是必要的，因为 Spring Security 的注册，在会话被摧毁时会被通知。没有它，会话信息不会从注册中移除。

   ```XML
   <listener>
           <listener-class>org.springframework.security.web.session.HttpSessionEventPublisher</listener-class>
   </listener>
   ```

   

   **Spring Security 在什么地方新建了会话，就算是我配置它去不要新建，通过设置 create-session 属性为 never。**

   这通常意味着，用户的应用在什么地方新建一个会话，但是他们并不知道。最常见的罪魁祸首是 JSP。许多用户并不知道 JSP 会默认创建恢复。为了方式 JSP 创建新的会话，增加一个 `<%@ page session=“false” %>` 到页面顶部。

   如果你对会话在哪里创建的有疑问，你可增加一些 debug 信息来更新它的位置。一种方式是增加一个 `javax.servlet.http.HttpSessionListener` 到你的应用，这会调用 `Thread.dumpStack()` 在 `sessionCreated` 方法中。

   

   **当执行一个 POST 时，我得到一个 403 Forbidden 回复。**

   如果，一个 HTTP 403 Forbidden 返回自一个 HTTP POST，但对一个 HTTP GET 是有效的，那么问题很可能是 CSRF。要不提供 CSRF token，或者禁止 CSRF 保护（不推荐）。

   

   **我使用 RequestDispatcher 转发一个请求到另一个 URL 地址，但我的安全限制并没有生效。**

   过滤器默认是不对转发或包含生效的。如果真的希望安全过滤器对转发，和/或，包含生效，那么你必须分别在 `web.xml` 中配置这些，使用 `<dispatcher>` 属性，或 `filter-mapping` 的子属性。

   

   **我在应用上下文中增加 Spring Security 到 `<global-method-security>` 属性，但是，如果我增加安全注解到 Spring MVC controller beans（Struts beans，等等） 时，它们好像没有生效。**

   在 Spring web 应用中，为了调度 Servlet，持有 Spring MVC beans 的应用上下文通常和主应用上下文不一样。它已经定义在 `myapp-servlet.xml` 中，这里 `myapp` 是在 `web.xml` 中的 Spring `DispatcherServlet` 的名字。一个应用可以拥有多个 `DispatcherServlet`，每一个都有自己独立的应用上下文。这些子上下文的 beans，对其他的应用是不可见的。“父” 应用上下文是通过定义在 `web.xml` 中的 `ContextLoaderListener` 来加载的，并对所有的子应用上下文可见。这个父应用上下文通常在你定义的安全配置的地方，包括 `<global-method-security>` 属性中。作为任何安全限制应用到方法上的结果，这些 web beans 不会被强制执行，因为 beans 不能从 `DispatcherServlet` 上下文中看到。你要不就将 `<global-method-security>` 移到 web 上下文中，或者将这些 beans 移到你的主应用上下文中。

   

   **我有一个用户，他一定已经被授权，但是当我在一些请求中试着访问 SpringSecurityContextHolder 时，Authentication 是 null。**

   为什么我不能看到这个用户的信息？

   如果你使用匹配 URL 模式的 `<intercept-url>` 中的 `filter='none'` 属性将请求从安全过滤器链中移除，那么 `SecurityContextHolder` 将不会被注入到请求中。检查 debug 日志来查看是否请求被传入到过滤器链中（你是可以读到 debug 日志的，没错吧？）。

   

   **认证 JSP 标签没有按我的方法安全注解生效，在使用 URL 属性时**

   当使用 `<sec:authorize>` 中的 `url` 属性时，方法安全不会隐藏连接，因为我们不能我们无法轻易地反向设计哪些URL映射到控制器重点，因为控制器可以依赖头部，当前用户等，来确定要调用的方法。

##### 14.5.3 Spring Security 架构问题

1. 我怎么知道类 X 在哪一个包中？
2. 命名空间是怎么关联传统 bean 配置的？
3. “ROLE_” 是什么意思，为什么在我的角色名中需要它？
4. 我怎么知道在我的应用要增加哪些依赖以配合 Spring Security？
5. 运行一个嵌入式 ApacheDS LDAP 服务需要什么依赖？
6. 什么是 UserDetailsService，我为什么需要它？



**我怎么知道类 X 在哪一个包中？**

定位一个类的最好方式是将 Spring Security 源码加载到你的 IDE 中。这个分布包含项目被划分的所有模块的源码。增加这些到你的源码路径，你可以直接观察到 Spring Security 类（在 Eclipse 中，`Ctrl-Shift-T`）。这也使得 debug 更加容易，并允许通过直接查看出现的代码来排除异常故障，以定位异常情况。



**命名空间是怎么关联传统 bean 配置的？**

这里有一个总览，关于参考手册的命名空间附录中命名空间创建的bean。这里也有一个详细的 blog 文章，叫做 “Behind the Spring Security Namespace”，在 `blog.springsorce.com`。如果希望知道全部的细节，那么代码在 `spring-security-config` 模块中，Spring Security 3.0 发布。你可能读过标准 Spring Framework 参考手册中命名空间解析章节的内容。



**“ROLE_” 是什么意思，为什么在我的角色名中需要它？**

Spring Security 有一个 voter-based 架构，这云溪一个访问决策被一系列的 `AccessDecisionVoter` 决定。voters 在 “配置属性” 上表现为一个安全的资源（例如方法调用，等）。用这种方式，不是所有的属性都和 voters 有关，一个 voter 需要知道什么时候要忽视一个属性（弃权），什么时候要投出允许或拒绝票，基于属性值。最常见的 voter 是 `RoleVoter`，这是默认的 voter，只要有带 “ROLE_” 前缀的属性。它将属性（例如“ROLE_USER”）与当前用户已分配的权限的名称进行简单比较。如果它找到匹配（它们具有 “ROLE_USER” 权限），则它投出授权票，否则它投出拒绝票。

前缀可以被更改，在 `RoleVoter` 的 `rolePrefix` 属性中。如果你只需在你的应用中使用角色，不需要其他自定义的 voters，那么你可以设置前缀为空字符串，这会导致 `RoleVoter` 对待所有属性为角色。



**我怎么知道在我的应用要增加哪些依赖以配合 Spring Security？**

这取决于你是用的特性和你开发的应用类型。Spring Security 3.0，这个项目 jars 被分为明显不同的功能区域，因此，你可以直接从应用程序中确认哪些 Spring Security jar 是需要的。所有的依赖都需要 `spring-security-core` jar。如果你正在开发一个 web 应用，你需要 `spring-security-web` jar。如果你正在使用安全命名空间配置，那么你需要 `spring-security-config` jar，对于 LDAP 支持，你需要 `spring-security-ldap` jar，等等之类。

对于第三方 jar，这个情况不一定这么明显。一个好的开端从与建立的应用实例的 WEB-INF/lib 目录中拷贝。对于基础应用，你可以以一个教程示例开始。如果你希望使用 LDAP ，字啊一个嵌入式测试服务器，那么使用 LDAP 示例作为一个开端。参考手册也包括 `http://static.springsource.org/spring-security/site/docs/3.1.x/reference/springsecurity-single.html#appendix-dependencies[an appendix] `，列出了第一级的依赖，对每一个 Spring Security 模块都一些信息，他们是必须的还是可选的。

如果你正在使用 maven 来构建的你项目，那么增加合适的 Spring Security 模块作为依赖到你的 `pom.xml` 文件中，会自动导入这些 jar 需要的核心 jars。任何在 Spring Security POM 中被标注为 “optional” 的都会需要在你需要的时候加入到你自己的 `pom.xml` 中。



**运行一个嵌入式 ApacheDS LDAP 服务需要什么依赖？**

如果你是用 maven，那么你需要加入以下的依赖到你的 `pom` 依赖中：

```XML
<dependency>
        <groupId>org.apache.directory.server</groupId>
        <artifactId>apacheds-core</artifactId>
        <version>1.5.5</version>
        <scope>runtime</scope>
</dependency>
<dependency>
        <groupId>org.apache.directory.server</groupId>
        <artifactId>apacheds-server-jndi</artifactId>
        <version>1.5.5</version>
        <scope>runtime</scope>
</dependency>
```

其他需要的 jar 需要过滤。



**什么是 UserDetailsService，我为什么需要它？**

`UserDetailsService` 是一个 DAO 接口，来载入对一个用户账号的数据。它没有其他功能，除了加载数据以供框架中的其他模块使用。它不负责认证用户。认证一个用户，使用用户名/密码集合，是最常见的，通过 `DaoAuthenticationProvider`，它会注入一个 `UserDetailsService` 来允许它加载密码（或其他数据），这样就可以与用户提交的值相比对。注意如果你使用 LDAP，那么这种方式是没有作用的。

如果你需要自定义你的认证方式，那么你应该实现 `AuthenticationProvider` 接口。查看 blog 文章来作为一个Google App Engine 集成 Spring Security 认证示例。

##### 14.5.4 常见 “如何” 问题

1. 我需要更多信息才能的登录，不只是用户名。
2. 我该怎么应用不同的拦截网址约束，当所请求的 URL 有 fragment 不一致。
3. 我怎么访问 `UserDetailsService` 中的用户 `IP` 地址（或，另外的 web 请求数据）。
4. 我怎么从 `UserDetailsService` 中访问 `HttpSession`。
5. 我怎么从 `UserDetailsService` 中访问用户的密码。
6. 我怎么在应用中动态地定义安全 URL。
7. 我怎么对 LDAP 进行认证，但是用户角色信息来自于数据库
8. 我希望修改一个命名空间创建的 bean 的属性，但是没有一个 schema 支持这种做法。



**我需要更多信息才能的登录，不只是用户名。**

我怎么增加一个额外的登录字段的支持（例如，一个公司名）？Spring Security 论坛中这个问题没重复提起，所以你可以通过 archives 来获得更多的信息（或者，Google）。

提交的登录信息，是在一个 `UsernamePasswordAuthenticationFilter` 中处理的。你将需要去自定义这个类，来处理额外的数据字段。一个选择是使用你自已定义的认证 token 类（而不是标准的 `UsernamePasswordAuthneticationFilter`），另一种是简单地将这些字段连接到用户名上（比如，使用 `.` 作为分隔），然后将它在 `UsernamePasswordAuthenticationToken` 中的用户名字段中传递。

你也需要真正的认证流程。如果你正在使用一个自定义的认证 token 类，比如说，你会需要写一个 `AuthenticationProvider` 来处理它（或，继承标准的 `DaoAuthenticationProvider`）。如果你连接了这些字段，你可以实现你自己的 `UserDetailsService`，来分开他们， 并为认证加载合适的用户数据。



**我该怎么应用不同的拦截网址约束，当所请求的 URL 有 fragment 不一致。**

你不能这样做，因为 fragment 没有从浏览器传输到服务器。从服务器的角度看，上面的 URL是相同的。这是一个常见的 GWT 用户的问题。



**我怎么访问 `UserDetailsService` 中的用户 `IP` 地址（或，另外的 web 请求数据）。**

显然，你不能这么做（没有重新保存类似，线程本地变量的数据），因为提供给接口的唯一信息是用户名。与其实现 `UserDetailsService`，你应该直接实现 `AuthenticationProvider`，并从提供的 `Authentication` token 中解析出数据。

在标准的 web 建立中，`Authentication` 中的 `getDetails()` 方法会返回一个 `WebAuthenticationDetails` 实例。如果你需要额外的信息，你可以注入一个自定义的 `AuthenticationDetailsSource` 到你使用的认证过滤器中。如果你正在使用命名空间，以 `<form-login>` 属性，那么你应该移除这个属性，并用 `<custom-filter>` 来替代它，申明指向显示配置。



**我怎么从 `UserDetailsService` 中访问 `HttpSession`。**

你不能。因为 `UserDetailsService` 并不感知到 Servlet API。如果你希望存储自定义客户数据，那么你应该自定义返回的 `UserDetails` 对象。通过线程本地的 `SecurityContextHolder` ，可以任意位置获取它。一个 `SecurityContextHolder.getContext().getAuthentication().getPrincipal()` 会返回这个自定义的对象。

如果真的希望访问 session，那么它必须通过自定义 web 层来实现。



**我怎么从 `UserDetailsService` 中访问用户的密码。**

你不能（也不应该）。你可能误解了它的目的。查看上面的 “什么是 `UserDetailsService`” 章节。



****我怎么在应用中动态地定义安全 URL。**

人们经常问关于如何存储数据库中安全 URL 和安全原数据属性的关系，而不是在应用上下文中。

第一件事是问自己是否真的需要这样做。如果一个应用要求安全，那么它也要求这个安全性基于一个定义的方式被测试。在应用到实际生产环境中之前，肯讷故需要进行审核和验收测试。一个有安全意识的组织应该知道，通过在配置数据库中修改一两行来允许运行时修改安全设置，可以立即抵消了辛勤测试的工作。如果你已经考虑到这一点（可能在你的应用中使用了多层安全措施），那么 Spring Security 允许你去完全自定义安全元数据的来源。如果你希望，那它可以是完全动态的。

方法和 web 安全都收 `AbstractSecurityIntercetpor` 子类的保护，它配置了一个 `SecurityMetadataSource` 来获取特定的方法或者过滤器调用的元数据。对于 web 安全，拦截器是 `FilterSecurityInterceptor` ，它使用标记接口 `FilterInvocationSecurityMetadataSource`。这个 “安全对象” 类型，它操作的是一个 `FilterInvocation`。默认的实现被使用，当在命名空间 `<http>` 和明确配置拦截器时，存储 URL 模式列表，以及他们相关的 "配置属性列表"（`ConfigAttribute` 实例），在内存 map 中。

为了从外部源中加载数据，你必须使用一个精确声明的安全过滤器链（特别是 Spring Security 的 `FilterChainProxy`），为了去自定义 `FilterSecurityInterceptor` bean。你不能使用命名空间。你应该实现 `FilterInvocationSecurityMetadataSource` 来为一个特定的 `FilterInvocation` 加载你希望的的数据。一个简单的大纲如下：

```Java
public class MyFilterSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {

    public List<ConfigAttribute> getAttributes(Object object) {
        FilterInvocation fi = (FilterInvocation) object;
            String url = fi.getRequestUrl();
            String httpMethod = fi.getRequest().getMethod();
            List<ConfigAttribute> attributes = new ArrayList<ConfigAttribute>();

            // Lookup your database (or other source) using this information and populate the
            // list of attributes

            return attributes;
    }

    public Collection<ConfigAttribute> getAllConfigAttributes() {
        return null;
    }

    public boolean supports(Class<?> clazz) {
        return FilterInvocation.class.isAssignableFrom(clazz);
    }
}
```

更多的信息，可以查看 `DefaultFilterInvocationSecurityMetadataSource` 的代码。



**我怎么对 LDAP 进行认证，但是用户角色信息来自于数据库**

`LdapAuthenticationProvider` bean（通常在 Spring Security 中处理 LDAP 认证的 bean）是和两个分开的策略接口一个配置的，一个处理认证，一个加载用户的 authorities，分别是 `LdapAuthenticator`，和 `LdapAuthoritresProvider`。`DefaultLdapAuthoritiesPopulator` 从 LDAP 目录中加载用户的 authorities，得到一些配置参数来允许你指定它怎么被存储。

为了使用 JDBC 替代，你可以自己实现这个接口，使用任何适合你的 schema 的 SQL：

```Java
public class MyAuthoritiesPopulator implements LdapAuthoritiesPopulator {
    @Autowired
    JdbcTemplate template;

    List<GrantedAuthority> getGrantedAuthorities(DirContextOperations userData, String username) {
        List<GrantedAuthority> = template.query("select role from roles where username = ?",
                                                                                                new String[] {username},
                                                                                                new RowMapper<GrantedAuthority>() {
            /**
             *  We're assuming here that you're using the standard convention of using the role
             *  prefix "ROLE_" to mark attributes which are supported by Spring Security's RoleVoter.
             */
            public GrantedAuthority mapRow(ResultSet rs, int rowNum) throws SQLException {
                return new SimpleGrantedAuthority("ROLE_" + rs.getString(1);
            }
        }
    }
}
```

你希望增加这个类型的 bean 到你的应用上下文，被注入到 `LdapAuthenticationProvider` 中。这在参看手册的 LDAP 章节 `configuring LDAP using explicit Spring beans` 部分中有说明。注意，你不能使用明明空间来配置它。你应该参考相关类和接口的 Java Doc。



**我希望修改一个命名空间创建的 bean 的属性，但是没有一个 schema 支持这种做法。**

除了房企明明空间，我还能做什么？

明明空间功能是故意有限制的，所以它不能覆盖全部你可以使用 plain beans 可以做的东西。如果你希望做的简单一些，像修改一个 bean，或注入一个不同的依赖，你可以通过在你的配置中增加一个 `BeanPostProcessor` 来完成。更多信息可以在 Spring 参考手册中找到。为了做到一点，你需要知道一些 bean 是怎么被创建的，所以你应该阅读 blog 文章 [how the namespace maps to Spring beans](https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/reference/htmlsingle/#appendix-faq-namespace-to-bean-mapping)。

通常，你需要 `BeanPostProcessor` 的 `postProcessBeforeInitializaion` 方法来增加功能。我们说你希望自定义 `usernamePasswordAuthenticationFilter` 使用的 `AuthenticationDetailsService`，（有 `form-login` 创建）。你希望提取一个 `CUSTOM_HEADER` 从请求中，并利用它来认证用户。这个方法的类会是这样：

```Java
public class BeanPostProcessor implements BeanPostProcessor {

        public Object postProcessAfterInitialization(Object bean, String name) {
                if (bean instanceof UsernamePasswordAuthenticationFilter) {
                        System.out.println("********* Post-processing " + name);
                        ((UsernamePasswordAuthenticationFilter)bean).setAuthenticationDetailsSource(
                                        new AuthenticationDetailsSource() {
                                                public Object buildDetails(Object context) {
                                                        return ((HttpServletRequest)context).getHeader("CUSTOM_HEADER");
                                                }
                                        });
                }
                return bean;
        }

        public Object postProcessBeforeInitialization(Object bean, String name) {
                return bean;
        }
}

```

